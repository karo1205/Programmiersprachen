Beispiel 1 der Angabe:
======================
0(9)(9~)(4!5#2+#@)@

Beispiel 2 der Angabe: (Achtung: Leerzeichen nach dem "-")
======================
A: (3!3!1- 2!1=()5!C@3#*)
C: (4!5#2+#@)
3 ^A3!4#3!@3#

3 Faktorielle:
--------------
3(3!3!1- 2!1=()5!(4!5#2+#@)@3#*)3!4#3!@3#


Operatoren:
===========
+, -, *, /, %, &, |, =, <, > : eh klar...
n!		-	Kopieren:	ersetzt das oberste Element im Stack durch das n-te Element im Stack (von oben)
n#		-	Löschen: 	nimmt das oberste Element vom Stack und löscht zusätzlich das n-te Elementim Stack (== Löschen des n-1 ten Elements) des aktuellen stacks
(x)@	-	Anwenden: 	Klammer wird entfernt Ausdruck kommt in Liste an vorderster Stelle, nichts sonst
(..)n ?	-	Auslesen: 	ersetzt den geklamerten Ausdruck durch den ASCII-Wert des n-ten Zeichens in der Klammer (linkestes Zeichen in der Klammer hat Index 0
(x)n;	-	Erweitern:	erweitert den geklammerten Ausdruck durch das durch den ASCII-Wert n repräsentierte Zeichen --> (xN)
a p$	-	Ausgabe:	gibt das Zeichen, welches durch den ASCII-Wert a repräsentiert wird, an die Stelle p im Display aus


Einige Muster:
==============
Oberstes Element löschen:
-------------------------
	2x:		
abc2# --> ab

Vertauschen der obersten 2 Elemente im Stack:
---------------------------------------------
	3!4#: 

Vertausche element n mit element m


[x y z a b] --> [x y z b a]

Holen des n-ten Elementes an die erste Stelle (erste wird zur zweiten)
----------------------------------------------------------------------
	(n+1)!(n+2)#



If (a Vergleich b) then T else F
--------------------------------
	a b <(T)(F)(4!5#2+#@)@
Funktioniert prinizipiell mit <, > und =, wobei letzteres auch auf ()-Ausdrücke
Achtung: wenn a und b Zahlen: Leerzeichen!

	Beispiele:
	----------
	0 1 <(T)(F)(4!5#2+#@)@ 		(Ergibt T)
	(abc)(abc)=(T)(F)(4!5#2+#@)@ 	(Ergibt T)



Testaufgabe 1:
==============
(Text) Zeile (Display)

(abcde)2!0?0$


CHECKs
------
(Error)0?
()0?

Einfache Ausgaben:
==================
"Error": 69 0$114 1$ 114 2$ 111 3$ 114 4$


Ausgabe eines Strings in Klammer:
=================================
Anfangsbedingung: 
Stack: auzugebender String

while ( != -1)
	duplicate string
	ersetze oberstes element (string) durch ASCII-Zeichen an index-Stelle
	Gib oberstes element aus an index-Stelle
	
(String) ?????

1!

(Error)0?$

(ab)
(ab)(ab)
(ab)xx
(abc)0?0$(bc)0?0$(c)0?0$

A: (3!3!1- 2!1=()5!C@3#*)

(3!3!


(String)0?0$
(String)0?-1=0$

x?-1=

(String)n?-1=()(n$)





Versuch: Näherung der Qudratwurzel
==================================
Näherungsformel der Wurzel (ca formel von Heron)
i = 0;
while(i < 10)
{
   // +2 um rundungsfehler auszugleichen
   xn = zahl/xn + xn / 2 + 2;
   i = i+1;
}
xn = xn + 1;

(2!2/2!)@				Errechnet Stack/2 und setzt es on top of the stack
(3!3!/3!2/+ 2+ 3#)@		Errechnet einen Durchlauf der obigen while-Schleife

 1000  (2!2/)@  				|Vorberechnung
(4!10<)							|logischer Vergleich (i<10?)
((4!1+ 5#4!5#4!5#)				|Erhöhe i um 1 und setzt wieder an erste Stelle
(2!4!3!/3!2/+ 2+ 3#)@3#)		|Wahrzweig
(1+)							|Falschzweig: xn=xn+1
(4!5#2+#@)@						|if_then_else

(9)(9~)(4!5#2+#@)@


0 1000 5000 (T)(T)(T)(F)@@@@


Iterativ --> Rekursiv
=====================
i=0
while (i<10)
	i++
	xn=zahl/xn+xn/2+2
end

---

i=0
xn=zahl/2
function (zahl, i, xn)
if < 10
	return function(zahl, i+1, zahl/xn+xn/2+2)
end
else return xn

function(zahl,0,zahl/2)



String-output (itertiv-->rekursiv
=================================
i=0
while getChar(String, i) != -1
	ouput(i, char(i))
end

----

function printChar(string i)
if (getChar(String, i) != -1)
	ouput(i, char(i))
	printChar(string, i++)
else	
	return

printChar("String", 0)

